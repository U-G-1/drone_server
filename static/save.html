<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>드론 좌표 저장</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; padding: 16px; }
    .row { margin: 8px 0; }
    input, button { padding: 8px; font-size: 16px; }
    #pos { font-weight: 600; }
    .video-container { margin-top:16px; }
    #consoleOutput {
      background:#000; color:#0f0; padding:10px;
      border-radius:6px; height:320px; overflow:auto; margin-top:12px;
    }

  </style>
</head>
<body>
  <h2>드론 좌표 저장</h2>

  <div class="row">
    <input id="chim" placeholder="굴뚝 이름 (chim_name)" />
    <button id="setChim">굴뚝 선택</button>
    <small id="chimStatus"></small>
  </div>

  <div class="row">
    <div>실시간 좌표(1초 갱신):</div>
    <div id="pos">x: -, y: -, z: -, slope: -</div>
  </div>

  <div class="row">
    <button id="saveBtn" disabled>저장</button>
    <small id="saveMsg"></small>
  </div>
  <!-- Camera -->
<div class="video-container">
  <h3>Camera Feeds</h3>
  <iframe id="camera1"
          src="https://droneview.ngrok.app/index.html"
          width="100%" height="420"
          frameborder="0" allowfullscreen>
  </iframe>
</div>

<!-- Console -->
<h3>Server Console Output</h3>
<div id="consoleOutput"></div>


<script>
  // ---- 굴뚝 이름 유지 (localStorage)
  const chimInput  = document.getElementById('chim');
  const chimStatus = document.getElementById('chimStatus');
  chimInput.value = localStorage.getItem('chimneyNumber') || '';
  chimInput.addEventListener('input', () => {
    localStorage.setItem('chimneyNumber', chimInput.value);
  });

  document.getElementById('setChim').onclick = async () => {
    const chimneyNumber = chimInput.value.trim();
    if (!chimneyNumber) { alert('굴뚝 이름을 입력하세요'); return; }
    const r = await fetch('/saveLocation', {
      method: 'POST', headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ chimneyNumber })
    });
    chimStatus.textContent = r.ok ? '쿠키 설정됨' : '쿠키 설정 실패';
  };

  // ---- UI refs
  const posEl    = document.getElementById('pos');
  const saveBtn  = document.getElementById('saveBtn');
  const saveMsg  = document.getElementById('saveMsg');
  const consoleOutput = document.getElementById('consoleOutput');

  function log(msg) {
    const d = document.createElement('div');
    d.textContent = msg;
    consoleOutput.appendChild(d);
    consoleOutput.scrollTop = consoleOutput.scrollHeight;
  }

  // ---- 최신 좌표 상태
  let latest = null;
  let lastTs = 0;

  function renderPos() {
    if (!latest) return;
    posEl.textContent = `x: ${latest.x}, y: ${latest.y}, z: ${latest.z}, slope: ${latest.slope ?? '-'}`;
  }

  function updateBtnState() {
    // 최근 3초 내 좌표가 있으면 저장 버튼 활성화
    const fresh = (Date.now() - lastTs) < 3000;
    saveBtn.disabled = !fresh;
  }
  setInterval(updateBtnState, 1000);

  // ---- A) WebSocket 수신 (있으면 push로 갱신)
  const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
  const ws = new WebSocket(`${wsProtocol}//${location.host}/ws/telemetry`);

  ws.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      if (data.type === "telemetry") {
        latest = data.data;
        lastTs = Date.now();
        renderPos();
      } else if (data.type === "consoleMessage") {
        log(data.data);
      }
    } catch (e) {
      console.error('WS parse error', e);
    }
  };
  ws.onclose = () => {
    log('[ws] 연결 종료');
    // WS 없어도 아래 폴링이 계속 갱신해줌
  };

  // ---- B) 1초 폴링: 페이지 로드 즉시 /saveLocation/measure 호출 (WS 미도착 보완)
  // 주의: /saveLocation/measure 는 내부적으로 파이썬 스크립트를 실행하므로
  // 실제 운영에선 스트리밍 방식(지속 연결)로 바꾸는 걸 권장. 지금은 간단 동작 확인용.
  let inflight = false; // 중복 호출 방지
  async function pollMeasure() {
    if (inflight) return;
    inflight = true;
    try {
      const r = await fetch('/saveLocation/measure', { method: 'POST' });
      if (r.ok) {
        const data = await r.json(); // {values, x, y, z}
        latest = { x: data.x, y: data.y, z: data.z, slope: null };
        lastTs = Date.now();
        renderPos();
      } else {
        // 에러 메시지 출력(너무 시끄러우면 주석)
        const err = await r.text();
        log('[measure error] ' + err);
      }
    } catch (e) {
      log('[measure fetch error] ' + e.message);
    } finally {
      inflight = false;
    }
  }

  // 페이지 로드시 즉시 1회 + 1초마다 반복
  pollMeasure();
  setInterval(pollMeasure, 1000);

  // ---- 저장 (프론트 주도: 최신 좌표 + chim_name POST)
  saveBtn.onclick = async () => {
    if (!latest) { alert('아직 좌표가 없습니다'); return; }
    const chim_name = chimInput.value.trim();
    if (!chim_name) { alert('굴뚝 이름을 입력하세요'); return; }

    const payload = {
      x: latest.x,
      y: latest.y,
      z: latest.z,
      slope: latest.slope ?? null,
      tag: chim_name
    };

    try {
      const r = await fetch('/telemetry', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload)
      });
      const data = await r.json();
      if (!r.ok) throw new Error(data.detail || '저장 실패');
      saveMsg.textContent = `저장 완료: ${chim_name}`;
      setTimeout(()=> saveMsg.textContent = '', 2000);
    } catch (err) {
      console.error(err);
      alert('저장 실패: ' + err.message);
    }
  };
</script>

</body>
</html>
